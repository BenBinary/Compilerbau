/*

	Vollständige Beschreibung einer Grammatik
	Dient als Grundlage für einen Parser oder einen Lexer

*/

options {

	STATIC = false;
	DEBUG_PARSER = true;

}


// Parser
PARSER_BEGIN(RegAusdruck)

public class RegAusdruck {


}

PARSER_END(RegAusdruck)


// Lexer
TOKEN : {

	<Char : ["a"-"z", "A"-"Z", "0"-"9"]>
	| <Empty : "\"\"" > | <EmptySet : "{}">
	| "(" | ")" | "*" | "|"

}


// Parserregeln / Grammatik
// Compilation Unit
// CU -- > 
Node cu() : {Node node; }{

  // Für AST gibt man hierdrin eine Knotenklasse zurück
  

  node = or() <EOF>

  {
	
    // Es lassen sich auch Aktionen ausführen, sobald der Java-Code erkannt wurde
	// Hier nach der Regel
	return node;
	
  }
  
}



// OR --> Concat ("|" Concat ) *
Node or() : {Node left, right; } {
  
	left = concat() (

	  	"|"
	  	concat()
		{ left = new Node(left, right) }
	)*

	{ return left; }
	
}


// Concat --> Star (Star)*
void concat() : {} {

	star() (star())*
	 
}

// Star --> Atom ("*")*		Bspl. a**
void star() : {} {
	atom() ("*")*

}

// Atom --> <Char> | <Empty> | <EmptySet> | "(" Or ")"
void atom() : {}{
	<Char >
	| <Empty>
	| <EmptySet>
	|  "(" or() ")"
}