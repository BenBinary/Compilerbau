/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. RegAusdruck.jj */
/*@egen*//*

	Vollst\u00e4ndige Beschreibung einer Grammatik
	Dient als Grundlage f\u00fcr einen Parser oder einen Lexer

*/


/*

	Default bei JJ-Tree
	Ohne Einschr\u00e4nkung w\u00fcrde f\u00fcr jedes NT ein Knoten erzeugt werden - mit den entsprechenden Kindern

	Mit NODE_DEFAULT_VOID = true; werden zun\u00e4chst keinen Knoten erzeugt, man muss explizit angeben welche Knoten erzeugt werden sollen
	 - Mit #KNOTEN gibt man entsprechende Knoten an
	 - Mit multi werden verschiedene Klassen erzeugt

	 
	 
*/

options {

	STATIC = false;
	DEBUG_PARSER = true;
	                         
	             

}


// Parser
PARSER_BEGIN(RegAusdruck)

public class RegAusdruck/*@bgen(jjtree)*/implements RegAusdruckTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTRegAusdruckState jjtree = new JJTRegAusdruckState();

/*@egen*/

}

PARSER_END(RegAusdruck)

// Lexer
TOKEN : {

	<Char : ["a"-"z", "A"-"Z", "0"-"9"]>
	| <Empty : "\"\"" > | <EmptySet : "{}">
	| "(" | ")" | "*" | "|"

}

// Parserregeln / Grammatik
// Compilation Unit
// CU -- > 
void cu() : {}{

  // F\u00fcr AST gibt man hierdrin eine Knotenklasse zur\u00fcck
   or() <EOF>

}



// OR --> Concat ("|" Concat ) *
Node or()     : {/*@bgen(jjtree) Or */
  ASTOr jjtn000 = new ASTOr(JJTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Or */
        try {
/*@egen*/
  
	concat() ("|" concat())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}


// Concat --> Star (Star)*
void concat()         : {/*@bgen(jjtree) Concat */
  ASTConcat jjtn000 = new ASTConcat(JJTCONCAT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Concat */
        try {
/*@egen*/

	star() (star())*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
	 
}

// Star --> Atom ("*")*		Bspl. a**
void star()       : {/*@bgen(jjtree) Star */
  ASTStar jjtn000 = new ASTStar(JJTSTAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Star */
        try {
/*@egen*/
	atom() ("*")*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/

}

// Atom --> <Char> | <Empty> | <EmptySet> | "(" Or ")"
void atom()       : {/*@bgen(jjtree) Atom */
  ASTAtom jjtn000 = new ASTAtom(JJTATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Atom */
        try {
/*@egen*/
	<Char >
	| <Empty>
	| <EmptySet>
	|  "(" or() ")"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}