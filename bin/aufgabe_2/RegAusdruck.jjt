/*

	### GENERIC ###

	Vollständige Beschreibung einer Grammatik
	Dient als Grundlage für einen Parser oder einen Lexer

*/


/*

	### AST-Erzeugung mithilfe von JJ-Tree ###
	
	Default bei JJ-Tree
	Ohne Einschränkung würde für jedes NT ein Knoten erzeugt werden - mit den entsprechenden Kindern

	Mit NODE_DEFAULT_VOID = true; werden zunächst keinen Knoten erzeugt, man muss explizit angeben welche Knoten erzeugt werden sollen
	 - Mit #KNOTEN gibt man entsprechende Knoten an
	 - Mit multi werden verschiedene Klassen erzeugt

	 Codeerzeugung
	 - jjtree <Dateiname>.jjt
	 - javacc <Dateiname>.jj
	 Für jede angegebene Knotenklasse wird eine extra Klasse (siehe Klassenstruktur) angelegt


		
		
	 Ändern mit Präfix mit NODE_PREFIX

	 TRACK_TOKENS = true;
	 Bestimmmen wo ein  Fehler beginnt und wieder endet.

	 In SimpleNode gibt es dann hierfür
	   	protected Token firstToken;
  		protected Token lastToken;
	 
*/

options {

	STATIC = false;
	DEBUG_PARSER = true;
	NODE_DEFAULT_VOID = true;
	MULTI = true;
	TRACK_TOKENS = true;
	VISITOR = true;
	

}


// Parser
PARSER_BEGIN(RegAusdruck)

package aufgabe_2;

public class RegAusdruck {

}

PARSER_END(RegAusdruck)

// Lexer
TOKEN : {

	<Char : ["a"-"z", "A"-"Z", "0"-"9"]>
	| <Empty : "\"\"" > | <EmptySet : "{}">
	| "(" | ")" | "*" | "|"

}

// Ignorieren von Leerzeichen und Tab-Stopps
SKIP : {

	" " | "\t"

}

// Parserregeln / Grammatik
// Compilation Unit
// CU -- > 
void cu() : {}{

  // Für AST gibt man hierdrin eine Knotenklasse zurück
   or() <EOF>

}

  

// OR --> Concat ("|" Concat ) *
void or() #Or(>1) : {} {

  	// TODO: Nehmen des obersten Element vom Stack
	
	// In #Or() kann es eine Bedingung geben, sobald ein Knoten angelegt wird
	// Bei #Or(> 1) wird dieser nur erzeugt, sobald ein Kindknoten vorhanden ist
  	
	concat() ("|" concat())*

	//  { jjtThis.firstConcat  }

}


// Concat --> Star (Star)*
void concat() #Concat(>1) : {} {

	star() (star())*
	 
}

// Star --> Atom ("*")*		Bspl. a**
// Welche Regel wird hier abhängig vom Lookahead ausgeführt?

// Syntaktischer Lookeahed: 	LOOKAHEAD(("a")*("*")) atom()("*")*
// Semantischer Lookeahed:		LOOKAHEAD( { getToken(15).kind==char }) atom()("*")*

// 

void star() #Star : {} {

	
	atom()("*")*
	

}

// Atom --> <Char> | <Empty> | <EmptySet> | "(" Or ")"
// Es kann schnell gehen, dass die Regeln nicht mehr eindeutig sind
// Die zweite Regel wird nicht ausgeführt
// Mit dem Lookahead 2 kann man die nächsten beiden Tokens einlesen

/*
		Warning: Choice conflict involving two expansions at
         line 117, column 9 and line 118, column 11 respectively.
         A common prefix is: <Char>

*/
void atom() #Atom : {}{
	//LOOKAHED(2) <Char>
	<Char> // "!"
	| <Empty>
	| <EmptySet>
	|  "(" or() ")"
}